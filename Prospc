5local Players = game:GetService("Players")
local RS = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local pcLabels, finished, pcState, hookedPCs, lastPercent = {}, {}, {}, {}, {}
local pendingUpdate = {}

local UPDATE_INTERVAL = 0.1
local SHOW_DISTANCE_SURV = 40
local SHOW_DISTANCE_BEAST = 20
local currentShowDist = SHOW_DISTANCE_SURV

local CHECK_OFFSET = Vector3.new(0, 1, 0)
local CHECK_RADIUS = 2

-- ================== Billboard ==================
local function findAttachPart(pc)
	if pc:IsA("Model") then
		local scr = pc:FindFirstChild("Screen")
		if scr and scr:IsA("BasePart") then return scr end
		if pc.PrimaryPart then return pc.PrimaryPart end
		for _,d in ipairs(pc:GetDescendants()) do
			if d:IsA("BasePart") then return d end
		end
	elseif pc:IsA("BasePart") then
		return pc
	end
	return nil
end

local function createBillboard(pc)
	if pcLabels[pc] then return pcLabels[pc] end
	local part = findAttachPart(pc)
	if not part then return end

	if part:FindFirstChild("PC_Billboard") then
		return pcLabels[pc]
	end

	local bb = Instance.new("BillboardGui")
	bb.Name = "PC_Billboard"
	bb.Size = UDim2.new(0, 100, 0, 40)
	bb.StudsOffset = Vector3.new(0, 2, 0)
	bb.AlwaysOnTop = true
	bb.MaxDistance = math.huge
	bb.Adornee = part
	bb.Parent = part

	local tl = Instance.new("TextLabel")
	tl.Size = UDim2.new(1,0,1,0)
	tl.BackgroundTransparency = 1
	tl.TextColor3 = Color3.new(1,1,1)
	tl.Font = Enum.Font.GothamBold
	tl.TextScaled = true
	tl.Text = "0%" -- máº·c Ä‘á»‹nh luĂ´n hiá»‡n 0%
	tl.Visible = true
	tl.Parent = bb

	local stroke = Instance.new("UIStroke")
	stroke.Thickness = 1
	stroke.Color = Color3.new(0,0,0)
	stroke.Parent = tl

	pcLabels[pc] = {label = tl, bb = bb, part = part}
	lastPercent[pc] = 0
	return pcLabels[pc]
end

local function clearAll()
	for _,v in pairs(pcLabels) do
		if v.bb then v.bb:Destroy() end
	end
	pcLabels, finished, pcState, hookedPCs, lastPercent, pendingUpdate = {}, {}, {}, {}, {}, {}
end

-- ================== Visibility Check ==================
local function isVisible(part)
	if not part then return false end
	local camPos = Camera.CFrame.Position
	local partPos = part.Position + CHECK_OFFSET
	local dir = (partPos - camPos).Unit * (partPos - camPos).Magnitude

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {LocalPlayer.Character, unpack(Players:GetPlayers())}
	params.FilterType = Enum.RaycastFilterType.Blacklist

	local result = workspace:Raycast(camPos, dir, params)
	if not result then return true end
	if result.Instance:IsDescendantOf(part.Parent) then
		return true
	end

	for _, offset in ipairs({
		Vector3.new(CHECK_RADIUS, 0, 0),
		Vector3.new(-CHECK_RADIUS, 0, 0),
		Vector3.new(0, CHECK_RADIUS, 0),
		Vector3.new(0, -CHECK_RADIUS, 0),
		Vector3.new(0, 0, CHECK_RADIUS),
		Vector3.new(0, 0, -CHECK_RADIUS)
	}) do
		local p = partPos + offset
		local dir2 = (p - camPos).Unit * (p - camPos).Magnitude
		local r = workspace:Raycast(camPos, dir2, params)
		if not r or r.Instance:IsDescendantOf(part.Parent) then
			return true
		end
	end
	return false
end

-- ================== Progress ==================
local function queueProgress(pc, value)
	if finished[pc] then return end
	if pcState[pc] == "ERROR" or pcState[pc] == "DONE" then return end

	local percent = math.floor(value * 100 + 0.5)
	if percent >= 100 then
		percent = 100
		finished[pc] = true
	end

	if percent ~= (lastPercent[pc] or -1) then
		if percent == 0 and (lastPercent[pc] or 0) > 0 then
			return
		end
		lastPercent[pc] = percent
		pendingUpdate[pc] = tostring(percent).."%"
	end
end

task.spawn(function()
	while true do
		for pc,text in pairs(pendingUpdate) do
			local pack = createBillboard(pc)
			if pack then
				if pack.label.Text ~= text then
					pack.label.Text = text
					pack.label.TextColor3 = Color3.new(1,1,1)
				end
			end
			pendingUpdate[pc] = nil
		end
		task.wait(UPDATE_INTERVAL)
	end
end)

-- ================== Action Hook ==================
local function nearestPC(pos, maxDist)
	local best,bd = nil, maxDist or 30
	for pc,_ in pairs(pcLabels) do
		local part = pcLabels[pc].part
		if part then
			local dist = (part.Position - pos).Magnitude
			if dist < bd then
				best, bd = pc, dist
			end
		end
	end
	return best
end

local function onActionProgress(plr, value)
	local tps = plr:FindFirstChild("TempPlayerStatsModule")
	if not tps then return end
	local currentAnim = tps:FindFirstChild("CurrentAnimation")
	if not currentAnim or currentAnim.Value ~= "Typing" then return end

	if not plr.Character then return end
	local hrp = plr.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then return end

	local pc = nearestPC(hrp.Position, 35)
	if pc then
		queueProgress(pc, value)
	end
end

local function hookPlayer(plr)
	local function attach(c)
		if c.Name == "TempPlayerStatsModule" then
			local ap = c:WaitForChild("ActionProgress", 10)
			if ap and ap:IsA("NumberValue") then
				ap:GetPropertyChangedSignal("Value"):Connect(function()
					onActionProgress(plr, ap.Value)
				end)
			end
		end
	end
	plr.ChildAdded:Connect(attach)
	local tps = plr:FindFirstChild("TempPlayerStatsModule")
	if tps then attach(tps) end
end
for _,p in ipairs(Players:GetPlayers()) do hookPlayer(p) end
Players.PlayerAdded:Connect(hookPlayer)

-- ================== Beast Check ==================
local function updateRole()
	local stats = LocalPlayer:FindFirstChild("TempPlayerStatsModule") or LocalPlayer:FindFirstChild("PlayerStats")
	if stats then
		local isBeast = stats:FindFirstChild("IsBeast")
		if isBeast then
			if isBeast.Value == true then
				currentShowDist = SHOW_DISTANCE_BEAST
			else
				currentShowDist = SHOW_DISTANCE_SURV
			end
		end
	end
end

local function watchStats()
	local stats = LocalPlayer:FindFirstChild("TempPlayerStatsModule") or LocalPlayer:FindFirstChild("PlayerStats")
	if stats then
		local isBeast = stats:FindFirstChild("IsBeast")
		if isBeast then
			isBeast.Changed:Connect(function()
				updateRole()
			end)
			updateRole()
		end
	end
end

LocalPlayer.CharacterAdded:Connect(function()
	task.wait(0.5)
	watchStats()
end)

watchStats()

-- ================== Screen State ==================
local function applyScreenState(pc, c)
	local pack = createBillboard(pc)
	if not pack then return end
	if c.G > c.R + 0.2 and c.G > c.B + 0.2 then
		pcState[pc] = "DONE"
		pack.label.Text = "DONE"
		pack.label.TextColor3 = Color3.new(0,1,0)
	elseif c.R > c.G + 0.2 and c.R > c.B + 0.2 then
		pcState[pc] = "ERROR"
		pack.label.Text = "ERROR"
		pack.label.TextColor3 = Color3.new(1,0,0)
	else
		if not finished[pc] then
			pcState[pc] = nil
		end
	end
end

local function watchPC(pc)
	if hookedPCs[pc] then return end
	hookedPCs[pc] = true
	local scr = pc:FindFirstChild("Screen")
	if scr and scr:IsA("BasePart") then
		applyScreenState(pc, scr.Color)
		scr:GetPropertyChangedSignal("Color"):Connect(function()
			applyScreenState(pc, scr.Color)
		end)
	end
end

-- ================== Map Scan ==================
task.spawn(function()
	while true do
		local map = RS:FindFirstChild("CurrentMap") and RS.CurrentMap.Value
		if map then
			for _,d in ipairs(map:GetDescendants()) do
				if d.Name == "ComputerTable" then
					createBillboard(d)
					watchPC(d)
				end
			end
		end
		task.wait(1)
	end
end)

-- ================== Render Visibility ==================
RunService.RenderStepped:Connect(function()
	local char = LocalPlayer.Character
	local hrp = char and char:FindFirstChild("HumanoidRootPart")
	local camPos = Camera.CFrame.Position

	for pc,pack in pairs(pcLabels) do
		local part,label = pack.part, pack.label
		if part and label then
			local origin = hrp and hrp.Position or camPos
			local dist = (part.Position - origin).Magnitude
			if dist <= currentShowDist and isVisible(part) then
				label.Visible = true
			else
				label.Visible = false
			end
		end
	end
end)

-- ================== Map Change ==================
if RS:FindFirstChild("CurrentMap") then
	RS.CurrentMap.Changed:Connect(function()
		clearAll()
	end)
end
